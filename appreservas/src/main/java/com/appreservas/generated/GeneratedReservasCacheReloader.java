package com.appreservas.generated;

import com.appreservas.reservas.cliente.generated.GeneratedClienteCacheHolder;
import com.appreservas.reservas.evento.generated.GeneratedEventoCacheHolder;
import com.appreservas.reservas.lugar.generated.GeneratedLugarCacheHolder;
import com.appreservas.reservas.organizador.generated.GeneratedOrganizadorCacheHolder;
import com.appreservas.reservas.reserva.generated.GeneratedReservaCacheHolder;
import com.appreservas.reservas.reservalugar.generated.GeneratedReservalugarCacheHolder;
import com.appreservas.reservas.sala.generated.GeneratedSalaCacheHolder;
import com.appreservas.reservas.sessao.generated.GeneratedSessaoCacheHolder;
import com.appreservas.reservas.utilizador.generated.GeneratedUtilizadorCacheHolder;
import com.speedment.common.annotation.GeneratedCode;
import com.speedment.enterprise.datastore.runtime.DataStoreHolder;
import com.speedment.enterprise.datastore.runtime.DataStoreReloader;
import com.speedment.enterprise.datastore.runtime.util.DataStoreHolderUtil;
import com.speedment.runtime.core.component.StreamSupplierComponent;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;

/**
 * A reloader that loads updates from a stream source and creates a new holder
 * for that state.
 * <p>
 * This file has been automatically generated by Speedment. Any changes made to
 * it will be overwritten.
 * 
 * @author Speedment
 */
@GeneratedCode("Speedment")
public abstract class GeneratedReservasCacheReloader implements DataStoreReloader {
    
    @Override
    public DataStoreHolder reload(StreamSupplierComponent streamSupplier, ExecutorService executor) {
        final CompletableFuture<GeneratedClienteCacheHolder> clienteHolder            = GeneratedClienteCacheHolder.reload(streamSupplier, executor);
        final CompletableFuture<GeneratedEventoCacheHolder> eventoHolder              = GeneratedEventoCacheHolder.reload(streamSupplier, executor);
        final CompletableFuture<GeneratedLugarCacheHolder> lugarHolder                = GeneratedLugarCacheHolder.reload(streamSupplier, executor);
        final CompletableFuture<GeneratedOrganizadorCacheHolder> organizadorHolder    = GeneratedOrganizadorCacheHolder.reload(streamSupplier, executor);
        final CompletableFuture<GeneratedReservaCacheHolder> reservaHolder            = GeneratedReservaCacheHolder.reload(streamSupplier, executor);
        final CompletableFuture<GeneratedReservalugarCacheHolder> reservalugarHolder  = GeneratedReservalugarCacheHolder.reload(streamSupplier, executor);
        final CompletableFuture<GeneratedSalaCacheHolder> salaHolder                  = GeneratedSalaCacheHolder.reload(streamSupplier, executor);
        final CompletableFuture<GeneratedSessaoCacheHolder> sessaoHolder              = GeneratedSessaoCacheHolder.reload(streamSupplier, executor);
        final CompletableFuture<GeneratedUtilizadorCacheHolder> utilizadorHolder      = GeneratedUtilizadorCacheHolder.reload(streamSupplier, executor);
        
        final DataStoreHolder holder;
        try {
            holder = new GeneratedReservasDataStoreHolder(
                clienteHolder.get(),
                eventoHolder.get(),
                lugarHolder.get(),
                organizadorHolder.get(),
                reservaHolder.get(),
                reservalugarHolder.get(),
                salaHolder.get(),
                sessaoHolder.get(),
                utilizadorHolder.get()
            );
        } catch (final ExecutionException | InterruptedException ex) {
            throw new RuntimeException("Error reloading caches.", ex);
        }
        
        DataStoreHolderUtil.decorateEntityStores(holder, executor);
        return holder;
    }
}